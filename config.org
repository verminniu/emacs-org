#+TITLE:  Vermin's Emacs Configuration

* Emacs Initialization
** Packages Sources

In order to install packages, it is useful to configure the package sources.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq package-archives '(("gnu" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
                           ("melpa" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/")
                           ("org" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/org/")))
#+END_SRC

** use-package

To be able to manage its configuration with =use-package= it is necessary to
first install it, if you don't already.

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (use-package delight :ensure t)
  (use-package use-package-ensure-system-package :ensure t)
#+END_SRC

* Start Up
** Better defaults

For a better user experience of GNU Emacs, here are the default values I use.

#+BEGIN_SRC emacs-lisp :tangle yes
	(setq-default
	 ad-redefinition-action 'accept                   ; Silence warnings for redefinition
	 cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
	 display-time-default-load-average nil            ; Don't display load average
	 fill-column 80                                   ; Set width for automatic line breaks
	 mode-require-final-newline t                     ; add a newline to end of file
	 help-window-select t                             ; Focus new help windows when opened
	 inhibit-startup-screen t                         ; Disable start-up screen
	 initial-scratch-message ""                       ; Empty the initial *scratch* buffer
	 kill-ring-max 128                                ; Maximum length of kill ring
	 load-prefer-newer t                              ; Prefers the newest version of a file
	 mark-ring-max 128                                ; Maximum length of mark ring
	 scroll-conservatively most-positive-fixnum       ; Always scroll by one line
	 select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
	 indent-tabs-mode nil                             ; Space to tab
	 tab-width 4                                      ; Set width for tabs
	 use-package-always-ensure t                      ; Avoid the :ensure keyword for each package
	 user-full-name "Vermin"                          ; Set the full name of the current user
	 user-mail-address "cattlenzq@163.com"            ; Set the email address of the current user
	 vc-follow-symlinks t                             ; Always follow the symlinks
	 make-backup-files nil							  ; close backup files
	 view-read-only t)                                ; Always open read-only buffers in view-mode
  ;  (cd "~/")                                         ; Move to the user directory
	(column-number-mode 1)                            ; Show the column number
	(display-time-mode 1)                             ; Enable time in the mode-line
	(fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
	(global-hl-line-mode)                             ; Hightlight current line
	(set-default-coding-systems 'utf-8)               ; Default to utf-8 encoding
	;;(set-default-coding-systems 'gb2312)               ; Default to gb2312 encoding
	;;(set-terminal-coding-system 'gb2312)
	;;(set-keyboard-coding-system 'gb2312)
	;;(set-language-environment "Chinese-GB")
	(prefer-coding-system 'gb2312)		;
	(show-paren-mode 1)                               ; Show the parent
	(add-to-list 'auto-mode-alist '("\\.inl\\'" . c++-mode))
	(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+END_SRC

** Customization

To avoid overloading the GNU Emacs custormization =init.el= file made by the
user with the UI, I add the generated code in a separate file.

I also made sure to follow the XDG base directory specification for the
=auto-save-file= folder, in order to keep my =~/.emacs.d= folder clean.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default
   auto-save-list-file-name (expand-file-name (format "~/.emacs.d/data/auto-save-list"))
   custom-file (expand-file-name (format "~/.emacs.d/data/custom.el")))
  (when (file-exists-p custom-file)
    (load custom-file t))
#+END_SRC

** Theme

I'm a big fan of [[https://github.com/arcticicestudio/nord-emacs][nord-theme]] and combined with [[https://github.com/seagle0128/doom-modeline][doom-modeline]], it's just
happiness.

*NOTE:* to be able to see icons in the =doom-modeline=, you will need to install
[[#Icons][all-the-icons]].

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package doom-themes
    :config
    (add-to-list 'custom-theme-load-path (expand-file-name "~/.emacs.d/themes/"))
    (load-theme 'doom-Iosvkem t)
    ;; Global settings (defaults)
	(setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled

	;; Enable flashing mode-line on errors
	(doom-themes-visual-bell-config)

	;; Enable custom neotree theme (all-the-icons must be installed!)
	;;(doom-themes-neotree-config)
	;; or for treemacs users
	(setq doom-themes-treemacs-theme "doom-colors") ; use the colorful treemacs theme
	(doom-themes-treemacs-config)

	;; Corrects (and improves) org-mode's native fontification.
	;;(doom-themes-org-config)
	)

  (use-package doom-modeline
    :defer 0.1
    :config (doom-modeline-mode))
#+END_SRC

** FlyCheck
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package flycheck
     :init
	 (global-flycheck-mode)
   )
   #+END_SRC
** LSP
#+BEGIN_SRC emacs-lisp :tangle yes
 (use-package lsp-mode
     :diminish lsp-mode
     :after yasnippet
     :hook (prog-mode . lsp-deferred)
     :bind (:map lsp-mode-map
            ("C-c C-d" . lsp-describe-thing-at-point))
     :init (setq lsp-auto-guess-root t       ; Detect project root
                 lsp-prefer-flymake nil      ; Use lsp-ui and flycheck
                 flymake-fringe-indicator-position 'right-fringe)
     :config
	 ;;(setq lsp-enable-snippet nil)
	 ;;(setq company-lsp-enable-snippet nil)
     ;; Configure LSP clients
     (use-package lsp-clients
       :ensure nil
       :init (setq lsp-clients-python-library-directories '("/usr/local/" "/usr/"))))

   (use-package lsp-ui
     :functions my-lsp-ui-imenu-hide-mode-line
     :commands lsp-ui-doc-hide
     :custom-face (lsp-ui-doc-background ((t (:background ,(face-background 'tooltip)))))
     :bind (:map lsp-ui-mode-map
            ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
            ([remap xref-find-references] . lsp-ui-peek-find-references)
            ("C-c u" . lsp-ui-imenu))
     :init (setq lsp-ui-doc-enable t
                 lsp-ui-doc-use-webkit nil
                 lsp-ui-doc-delay 1.0
                 lsp-ui-doc-include-signature t
                 lsp-ui-doc-position 'at-point
                 lsp-ui-doc-border (face-foreground 'default)

                 lsp-ui-sideline-enable nil
                 lsp-ui-sideline-ignore-duplicate t)
     :config
     (add-to-list 'lsp-ui-doc-frame-parameters '(right-fringe . 8))

     ;; `C-g'to close doc
     (advice-add #'keyboard-quit :before #'lsp-ui-doc-hide)

     ;; Reset `lsp-ui-doc-background' after loading theme
     (add-hook 'after-load-theme-hook
               (lambda ()
                 (setq lsp-ui-doc-border (face-foreground 'default))
                 (set-face-background 'lsp-ui-doc-background
                                      (face-background 'tooltip))))

     ;; WORKAROUND Hide mode-line of the lsp-ui-imenu buffer
     ;; @see https://github.com/emacs-lsp/lsp-ui/issues/243
     (defun my-lsp-ui-imenu-hide-mode-line ()
       "Hide the mode-line in lsp-ui-imenu."
       (setq mode-line-format nil))
     (advice-add #'lsp-ui-imenu :after #'my-lsp-ui-imenu-hide-mode-line))

   (use-package company-lsp
     :init (setq company-lsp-cache-candidates 'auto))

   ;; Debug
   (use-package dap-mode
     :diminish
     :functions dap-hydra/nil
     :bind (:map lsp-mode-map
            ("<f5>" . dap-debug)
            ("M-<f5>" . dap-hydra))
     :hook ((after-init . dap-mode)
            (dap-mode . dap-ui-mode)
            (dap-session-created . (lambda (&_rest) (dap-hydra)))
            (dap-terminated . (lambda (&_rest) (dap-hydra/nil)))

            (python-mode . (lambda () (require 'dap-python)))
            (ruby-mode . (lambda () (require 'dap-ruby)))
            (go-mode . (lambda () (require 'dap-go)))
            (java-mode . (lambda () (require 'dap-java)))
            ((c-mode c++-mode objc-mode swift) . (lambda () (require 'dap-lldb)))
            (php-mode . (lambda () (require 'dap-php)))
            (elixir-mode . (lambda () (require 'dap-elixir)))
            ((js-mode js2-mode) . (lambda () (require 'dap-chrome)))))

   ;; `lsp-mode' and `treemacs' integration.
   (use-package lsp-treemacs
     :commands lsp-treemacs-errors-list
   )

   (use-package helm-lsp
     :commands helm-lsp-workspace-symbol
   )
#+end_SRC
** Turn off mouse interface

Since I never use the mouse with GNU Emacs, I prefer not to use certain
graphical elements as seen as the menu bar, toolbar, scrollbar and tooltip that
I find invasive.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when window-system
    (menu-bar-mode -1)              ; Disable the menu bar
    (scroll-bar-mode -1)            ; Disable the scroll bar
    (tool-bar-mode -1)              ; Disable the tool bar
    (tooltip-mode -1))              ; Disable the tooltips
#+END_SRC

* Languages
** Emacs Lisp

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package elisp-mode :ensure nil :delight "ξ ")
#+END_SRC

*** Eldoc

Provides minibuffer hints when working with Emacs Lisp.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package eldoc
    :delight
    :hook (emacs-lisp-mode . eldoc-mode))
#+END_SRC

** Python
   Lsp-mode will start py on python mode

   #+BEGIN_SRC shell :tangle no
   pip install 'python-language-server[all]'
   pip3 install 'python-language-server[all]'
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
   ;; Python Mode
   ;; Install:
   ;;   pip install pyflakes
   ;;   pip install autopep8
   ;;   change to python3
   (use-package python
     :ensure nil
	 :defines gud-pdb-command-name pdb-path
	 :config
	 ;; Disable readline based native completion
	 (setq python-shell-completion-native-enable nil)
	 (setq python-indent-offset 4
        python-sort-imports-on-save t
        python-shell-interpreter "python3"
        pippel-python-command "python3"
        importmagic-python-interpreter "python3"
        flycheck-python-pylint-executable "pylint"
        flycheck-python-flake8-executable "flake8")

	 (add-hook 'inferior-python-mode-hook
            (lambda ()
              ;; (bind-key "C-c C-z" #'kill-buffer-and-window inferior-python-mode-map)
              (process-query-on-exit-flag (get-process "Python"))))

	  ;; Live Coding in Python
	  (use-package live-py-mode)

	  ;; Format using YAPF
	  ;; Install: pip install yapf
	  (use-package yapfify
        :diminish yapf-mode
        :hook (python-mode . yapf-mode)))
     #+END_SRC
** C++
   c++ lsp server
   disable cquery and ccls to use clangd as lsp server
   cquery not support new lsp-mode

   =cquery=
   #+BEGIN_SRC emacs-lisp :tangle no
   (with-eval-after-load 'projectile
   (setq projectile-project-root-files-top-down-recurring
        (append '("compile_commands.json"
                  ".cquery")
                projectile-project-root-files-top-down-recurring)))

   (use-package cquery
    :commands lsp
	:hook ((c-mode c++-mode objc-mode cuda-mode) . (lambda ()
	                                                  (require 'cquery)
													  (lsp)
													  ))
    :config
	(setq cquery-executable "cquery")
	(setq cquery-extra-args '("--log-file=~/.cquery/log/cq.log"))
	(setq cquery-cache-dir "~/.cquery/cache")
	(setq cquery-extra-init-params '(:index (:comments 2) :cacheFormat "msgpack" :completion (:detailedLabel t)))
	;;(setq cquery-sem-highlight-method 'overlay)
	(setq cquery-sem-highlight-method 'font-lock)
	(cquery-use-default-rainbow-sem-highlight)
	)
   #+END_SRC

   =ccls=
   #+BEGIN_SRC emacs-lisp :tangle yes
   (with-eval-after-load 'projectile
   (setq projectile-project-root-files-top-down-recurring
        (append '("compile_commands.json"
                  ".ccls")
                projectile-project-root-files-top-down-recurring)))

   (use-package ccls
    :commands lsp
	:hook ((c-mode c++-mode objc-mode cuda-mode) . (lambda ()
	                                                  (require 'ccls)
													  (lsp)
													  ))
    :config
	(setq ccls-executable "ccls")
	(setq ccls-extra-args '("--log-file=~/.ccls/log/ccls.log"))
	;;(setq ccls-cache-dir "~/.ccls/cache")
	(setq ccls-initialization-options '(:index (:comments 2) :completion (:detailedLabel t)))
	(setq ccls-sem-highlight-method 'font-lock)
	;; alternatively, (setq ccls-sem-highlight-method 'overlay)
	;; For rainbow semantic highlighting
	(ccls-use-default-rainbow-sem-highlight)
	)

   #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package google-c-style				;
	:hook ((c-mode c++-mode) . google-set-c-style)
		   (c-mode-common . google-make-newline-indent))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
  ;; C/C++ Mode -- use google c-style
  (use-package cc-mode
    :ensure nil
	:bind (:map c-mode-base-map
                ("C-c c" . compile))
	;;:hook (c-mode-common . (lambda ()
    ;;            (c-set-style "k&r")
    ;;            (setq tab-width 4)
    ;;            (setq c-basic-offset 4)))
  )
  #+END_SRC

  #+BEGIN_SRC  emacs-lisp :tangle yes
  (use-package modern-cpp-font-lock
	:diminish
	:init (modern-c++-font-lock-global-mode t)
  )
  #+END_SRC
** GO
   #+BEGIN_SRC emacs-lisp :tangle yes
   ;;; Commentary:
   ;;
   ;; Golang configurations.
   ;;
   ;; Go packages:
   ;; go get -u github.com/mdempsky/gocode
   ;; go get -u github.com/rogpeppe/godef
   ;; go get -u golang.org/x/tools/cmd/gopls
   ;; go get -u golang.org/x/tools/cmd/goimports
   ;; go get -u golang.org/x/tools/cmd/gorename
   ;; go get -u golang.org/x/tools/cmd/gotype
   ;; go get -u golang.org/x/tools/cmd/godoc
   ;; go get -u github.com/go-delve/delve/cmd/dlv
   ;; go get -u github.com/josharian/impl
   ;; go get -u github.com/cweill/gotests/...
   ;; go get -u github.com/fatih/gomodifytags
   ;; go get -u github.com/davidrjenni/reftools/cmd/fillstruct
   ;; go get -u github.com/uudashr/gopkgs/cmd/gopkgs
   ;; go get -u onnef.co/go/tools/...
   ;;

 ;; Golang
 (use-package go-mode
   :bind (:map go-mode-map
		  ([remap xref-find-definitions] . godef-jump)
		  ("C-c R" . go-remove-unused-imports)
		  ("<f1>" . godoc-at-point))
   :config
   ;; Format with `goimports' if possible, otherwise using `gofmt'
   (when (executable-find "goimports")
	 (setq gofmt-command "goimports"))
   (add-hook 'before-save-hook #'gofmt-before-save)

   (use-package go-dlv)
   (use-package go-fill-struct)
   (use-package go-rename)
   (use-package golint)
   (use-package govet)

   (use-package go-impl
	 :functions (go-packages-gopkgs go-root-and-paths go-packages-fd)
	 :config
	 ;; `go-packages-native', remiplement it.
	 (cond
	  ((executable-find "gopkgs")
	   (defun go-packages-gopkgs()
		 "Return a list of all Go packages, using `gopkgs'."
		 (sort (process-lines "gopkgs") #'string<))
	   (setq go-packages-function #'go-packages-gopkgs))
	  ((executable-find "fd")
	   (defun go-packages-fd ()
		 "Return a list of all installed Go packages, using `fd'."
		 (sort
		  (delete-dups
		   (cl-mapcan
			'(lambda (topdir)
			   (let ((pkgdir (concat topdir "/pkg/")))
				 (--> (shell-command-to-string (concat "fd -e a . " pkgdir))
					  (split-string it "\n")
					  (-map (lambda (str)
							  (--> (string-remove-prefix pkgdir str)
								   (string-trim-left it ".*?/")
								   (string-remove-suffix ".a" it)
								   )
							  ) it))))
			(go-root-and-paths)))
		  #'string<))
	   (setq go-packages-function #'go-packages-fd))))

   (use-package go-tag
	 :bind (:map go-mode-map
			("C-c t" . go-tag-add)
			("C-c T" . go-tag-remove))
	 :config (setq go-tag-args (list "-transform" "camelcase")))

   (use-package go-gen-test
	 :bind (:map go-mode-map
			("C-c C-t" . go-gen-test-dwim)))

   (use-package gotest
	 :bind (:map go-mode-map
			("C-c a" . go-test-current-project)
			("C-c m" . go-test-current-file)
			("C-c ." . go-test-current-test)
			("C-c x" . go-run))))

 ;; Local Golang playground for short snippets
(use-package go-playground
  :diminish
  :commands go-playground-mode)

   #+END_SRC
* Advanced Configuration
** Icons
To integrate icons with =doom-modeline=, =switch-to-buffer=, =counsel-find-file=
and many other functions; [[https://github.com/domtronn/all-the-icons.el/][all-the-icons]] is just the best package that you can
find.

*NOTE:* if it's the first time that you install the package, you must run
=M-x all-the-icons-install-fonts=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package all-the-icons
  )

  (use-package all-the-icons-dired
  :config
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
  )

#+END_SRC

** Dashboard

Always good to have a dashboard.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dashboard
    :ensure t
    :config
	(setq dashboard-items '((recents  . 5)
                        (bookmarks . 5)
                        (projects . 5)
                        (agenda . 5)
                        (registers . 5)))
	(setq dashboard-set-heading-icons t)
	(setq dashboard-set-file-icons t)
	(dashboard-setup-startup-hook)
	)
#+END_SRC

** Dired

For those who didn't know, GNU Emacs is also a file explorer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired
    :ensure nil
    :delight "Dired "
    :custom
    (dired-auto-revert-buffer t)
    (dired-dwim-target t)
    (dired-hide-details-hide-symlink-targets nil)
    (dired-listing-switches "-alh")
    (dired-ls-F-marks-symlinks nil)
    (dired-recursive-copies 'always))
#+END_SRC

** Company
=company= provides auto-completion at point and to Displays a small pop-in
containing the candidates.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :defer 0.5
    :delight
	:init
	(add-hook 'after-init-hook 'global-company-mode)
    :custom
    (company-begin-commands '(self-insert-command))
    (company-idle-delay .1)
    (company-minimum-prefix-length 2)
    (company-show-numbers t)
    (company-tooltip-align-annotations 't)
    (global-company-mode t)
    :config
    (define-key company-active-map (kbd "C-n") 'company-select-next)
    (define-key company-active-map (kbd "C-p") 'company-select-previous)
;;	(delete 'company-dabbrev 'company-backends)
;;	(add-to-list 'company-backends #'company-dabbrev)
	(setq company-dabbrev-char-regexp "[\\.0-9a-zA-Z-_'/]")
	(setq company-dabbrev-code-other-buffers 'all)
  )



#+END_SRC

I use =company= with =company-box= that allows a company front-end with icons.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-box
    :after company
    :delight
    :hook (company-mode . company-box-mode))
#+END_SRC

** Buffers

Buffers can quickly become a mess. For some people, it's not a problem, but I
like being able to find my way easily.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer))

  (use-package ibuffer-projectile
    :after ibuffer
    :preface
    (defun my/ibuffer-projectile ()
      (ibuffer-projectile-set-filter-groups)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))
    :hook (ibuffer . my/ibuffer-projectile))
#+END_SRC

** History

Provides the ability to have commands and their history saved so that whenever
you return to work, you can re-run things as you need them. This is not a
radical function, it is part of a good user experience.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package savehist
    :ensure nil
    :custom
    (history-delete-duplicates t)
    (history-length t)
    (savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
    (savehist-file (expand-file-name (format "~/.emacs.d/cache/history")))
    (savehist-save-minibuffer-history 1)
    :config (savehist-mode 1))
#+END_SRC

** Hydra

Hydra allows me to display a list of all the commands implemented in the echo
area and easily interact with them.

#+BEGIN_QUOTE
Once you summon the Hydra through the prefixed binding (the body + any one
head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very
seamless, it's like a minor mode that disables itself auto-magically.

[[https://github.com/abo-abo/hydra][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :bind (("C-c L" . hydra-ledger/body)
           ("C-c b" . hydra-buffer/body)
           ("C-c c" . hydra-clock/body)
           ("C-c e" . hydra-erc/body)
           ("C-c f" . hydra-flycheck/body)
           ("C-c g" . hydra-go-to-file/body)
           ("C-c m" . hydra-magit/body)
           ("C-c o" . hydra-org/body)
           ("C-c p" . hydra-projectile/body)
           ("C-c s" . hydra-spelling/body)
           ("C-c u" . hydra-upload/body)
           ("C-c y" . hydra-yasnippet/body)
           ("C-c w" . hydra-windows/body)))
#+END_SRC

*** Hydra / Buffer

Group Buffer commands.


#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-buffer (:color blue)
    "
    ^
    ^Buffer^             ^Do^
    ^──────^─────────────^──^──────────
    _q_ quit             _k_ kill
    ^^                   _l_ list
    ^^                   _n_ next
    ^^                   _p_ previous
    ^^                   ^^
    "
    ("q" nil)
    ("k" kill-buffer)
    ("l" ibuffer)
    ("n" next-buffer)
    ("p" previous-buffer))
#+END_SRC

*** Hydra / Clock

Group clock commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-clock (:color blue)
    "
    ^
    ^Clock^             ^Do^
    ^─────^─────────────^──^─────────
    _q_ quit            _c_ cancel
    ^^                  _d_ display
    ^^                  _e_ effort
    ^^                  _i_ in
    ^^                  _j_ jump
    ^^                  _o_ out
    ^^                  _r_ report
    ^^                  ^^
    "
    ("q" nil)
    ("c" org-clock-cancel)
    ("d" org-clock-display)
    ("e" org-clock-modify-effort-estimate)
    ("i" org-clock-in)
    ("j" org-clock-goto)
    ("o" org-clock-out)
    ("r" org-clock-report))
#+END_SRC

*** Hydra / ERC

Group ERC commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-erc (:color blue)
    "
    ^
    ^ERC^             ^Do^
    ^───^─────────────^──^────────────
    _q_ quit          _c_ connect
    ^^                _d_ disconnect
    ^^                _j_ join
    ^^                _n_ names
    ^^                _u_ users
    ^^                ^^
    "
    ("q" nil)
    ("c" my/erc-start-or-switch)
    ("d" erc-quit-server)
    ("j" erc-join-channel)
    ("n" erc-channel-names)
    ("u" my/erc-count-users))
#+END_SRC

*** Hydra / Flycheck

Group Flycheck commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-flycheck (:color blue)
    "
    ^
    ^Flycheck^          ^Errors^            ^Checker^
    ^────────^──────────^──────^────────────^───────^─────
    _q_ quit            _<_ previous        _?_ describe
    _M_ manual          _>_ next            _d_ disable
    _v_ verify setup    _f_ check           _m_ mode
    ^^                  _l_ list            _s_ select
    ^^                  ^^                  ^^
    "
    ("q" nil)
    ("<" flycheck-previous-error :color pink)
    (">" flycheck-next-error :color pink)
    ("?" flycheck-describe-checker)
    ("M" flycheck-manual)
    ("d" flycheck-disable-checker)
    ("f" flycheck-buffer)
    ("l" flycheck-list-errors)
    ("m" flycheck-mode)
    ("s" flycheck-select-checker)
    ("v" flycheck-verify-setup))
#+END_SRC

*** Hydra / Go To

Group jump-to-files commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-go-to-file (:color blue)
    "
    ^
    ^Go To^           ^Config^            ^Agenda             ^Other^
    ^─────^───────────^──────^────────────^──────^────────────^─────^────────
    _q_ quit          _ca_ alacritty      _ac_ contacts       _ob_ book
    ^^                _cd_ dunst          _af_ findmycat      _ol_ learning
    ^^                _ce_ emacs          _ao_ organizer      _om_ movies
    ^^                _ci_ i3             _ap_ people         _op_ purchases
    ^^                _cn_ neofetch       _ar_ routine        _ou_ usb
    ^^                _cp_ polybar        _as_ school         ^^
    ^^                _cq_ qutebrowser    ^^                  ^^
    ^^                _cR_ rofi           ^^                  ^^
    ^^                _cr_ ranger         ^^                  ^^
    ^^                _cs_ sway           ^^                  ^^
    ^^                _ct_ tmux           ^^                  ^^
    ^^                ^^                  ^^                  ^^
    "
    ("q" nil)
    ("ac" (find-file "~/.personal/agenda/contacts.org"))
    ("af" (find-file "~/.personal/agenda/findmycat.org"))
    ("ao" (find-file "~/.personal/agenda/organizer.org"))
    ("ap" (find-file "~/.personal/agenda/people.org"))
    ("ar" (find-file "~/.personal/agenda/routine.org"))
    ("as" (find-file "~/.personal/agenda/school.org"))
    ("ca" (find-file (format "%s/alacritty/alacritty.yml" xdg-config)))
    ("cd" (find-file (format "%s/dunst/dunstrc" xdg-config)))
    ("ce" (find-file "~/.emacs.d/config.org"))
    ("ci" (find-file (format "%s/i3/config" xdg-config)))
    ("cn" (find-file (format "%s/neofetch/config.conf" xdg-config)))
    ("cp" (find-file (format "%s/polybar/config" xdg-config)))
    ("cq" (find-file (format "%s/qutebrowser/config.py" xdg-config)))
    ("cR" (find-file (format "%s/rofi/config.rasi" xdg-config)))
    ("cr" (find-file (format "%s/ranger/rc.conf" xdg-config)))
    ("cs" (find-file (format "%s/sway/config" xdg-config)))
    ("ct" (find-file (format "%s/tmux/tmux.conf" xdg-config)))
    ("ob" (find-file "~/.personal/other/books.org"))
    ("ol" (find-file "~/.personal/other/learning.org"))
    ("om" (find-file "~/.personal/other/movies.org"))
    ("op" (find-file "~/.personal/other/purchases.org"))
    ("ou" (find-file "~/.personal/other/usb.org")))
#+END_SRC

*** Hydra / Ledger

Group Ledger commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-ledger (:color blue)
    "
    ^
    ^Ledger^             ^Do^
    ^──────^─────────────^──^────────
    _q_ quit             _a_ add
    ^^                   _c_ clear
    ^^                   _C_ copy
    ^^                   _d_ delete
    ^^                   _r_ report
    ^^                   ^^
    "
    ("q" nil)
    ("a" ledger-add-transaction)
    ("c" ledger-mode-clean-buffer)
    ("C" ledger-copy-transaction-at-point)
    ("d" ledger-delete-current-transaction)
    ("r" ledger-report))
#+END_SRC

*** Hydra / Magit

Group Magit commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-magit (:color blue)
    "
    ^
    ^Magit^             ^Do^
    ^─────^─────────────^──^────────
    _q_ quit            _b_ blame
    ^^                  _c_ clone
    ^^                  _i_ init
    ^^                  _s_ status
    ^^                  ^^
    "
    ("q" nil)
    ("b" magit-blame)
    ("c" magit-clone)
    ("i" magit-init)
    ("s" magit-status))
#+END_SRC

*** Hydra / Org

Group Org commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-org (:color blue)
    "
    ^
    ^Org^             ^Do^
    ^───^─────────────^──^─────────────
    _q_ quit          _A_ archive
    ^^                _a_ agenda
    ^^                _c_ capture
    ^^                _d_ decrypt
    ^^                _i_ insert-link
    ^^                _j_ jump-task
    ^^                _k_ cut-subtree
    ^^                _o_ open-link
    ^^                _r_ refile
    ^^                _s_ store-link
    ^^                _t_ todo-tree
    ^^                ^^
    "
    ("q" nil)
    ("A" my/org-archive-done-tasks)
    ("a" org-agenda)
    ("c" org-capture)
    ("d" org-decrypt-entry)
    ("k" org-cut-subtree)
    ("i" org-insert-link-global)
    ("j" my/org-jump)
    ("o" org-open-at-point-global)
    ("r" org-refile)
    ("s" org-store-link)
    ("t" org-show-todo-tree))
#+END_SRC

*** Hydra / Projectile

Group Projectile commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-projectile (:color blue)
    "
    ^
    ^Projectile^        ^Buffers^           ^Find^              ^Search^
    ^──────────^────────^───────^───────────^────^──────────────^──────^────────────
    _q_ quit            _b_ list            _d_ directory       _r_ replace
    _i_ reset cache     _k_ kill all        _D_ root            _R_ regexp replace
    ^^                  _S_ save all        _f_ file            _s_ search
    ^^                  ^^                  _p_ project         ^^
    ^^                  ^^                  ^^                  ^^
    "
    ("q" nil)
    ("b" counsel-projectile-switch-to-buffer)
    ("d" counsel-projectile-find-dir)
    ("D" projectile-dired)
    ("f" counsel-projectile-find-file)
    ("i" projectile-invalidate-cache :color red)
    ("k" projectile-kill-buffers)
    ("p" counsel-projectile-switch-project)
    ("r" projectile-replace)
    ("R" projectile-replace-regexp)
    ("s" counsel-rg)
    ("S" projectile-save-project-buffers))
#+END_SRC

*** Hydra / Spelling

Group spelling commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-spelling (:color blue)
    "
    ^
    ^Spelling^          ^Errors^            ^Checker^
    ^────────^──────────^──────^────────────^───────^───────
    _q_ quit            _<_ previous        _c_ correction
    ^^                  _>_ next            _C_ clear
    ^^                  _f_ find            _d_ dictionary
    ^^                  ^^                  _l_ language
    ^^                  ^^                  _s_ switch
    ^^                  ^^                  _w_ wiki
    "
    ("q" nil)
    ("<" flyspell-correct-previous :color pink)
    (">" flyspell-correct-next :color pink)
    ("c" langtool-correct-buffer)
    ("C" langtool-check-done)
    ("d" ispell-change-dictionary)
    ("f" langtool-check)
    ("l" (message "Current language: %s (%s)" langtool-default-language ispell-current-dictionary))
    ("s" my/switch-language)
    ("w" wiki-summary))
#+END_SRC

*** Hydra / TypeScript

Group TypeScript commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-typescript (:color blue)
    "
    ^
    ^TypeScript^          ^Do^
    ^──────────^──────────^──^────────
    _q_ quit             _b_ back
    ^^                   _e_ errors
    ^^                   _j_ jump
    ^^                   _r_ references
    ^^                   _R_ restart
    ^^                   ^^
    "
    ("q" nil)
    ("b" tide-jump-back)
    ("e" tide-project-errors)
    ("j" tide-jump-to-definition)
    ("r" tide-references)
    ("R" tide-restart-server))
#+END_SRC

*** Hydra / Upload

Group upload commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-upload (:color blue)
    "
    ^
    ^Upload^          ^Do^
    ^──────^──────────^──^────────
    _q_ quit          _b_ buffer
    ^^                _i_ image
    ^^                _r_ region
    ^^                ^^
    "
    ("q" nil)
    ("b" webpaste-paste-buffer)
    ("i" imgbb-upload)
    ("r" webpaste-paste-region))
#+END_SRC

*** Hydra / YASnippet

Group YASnippet commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-yasnippet (:color blue)
    "
    ^
    ^YASnippet^          ^Do^
    ^─────────^──────────^──^────────
    _q_ quit             _i_ insert
    ^^                   _m_ mode
    ^^                   _n_ new
    ^^                   ^^
    "
    ("q" nil)
    ("i" ivy-yasnippet)
    ("m" yas-minor-mode)
    ("n" yas-new-snippet))
#+END_SRC

*** Hydra / Windows

Group window-related commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-windows (:color pink)
    "
    ^
    ^Windows^           ^Window^            ^Zoom^
    ^───────^───────────^──────^────────────^────^──────
    _q_ quit            _b_ balance         _-_ out
    ^^                  _i_ heighten        _+_ in
    ^^                  _j_ narrow          _=_ reset
    ^^                  _k_ lower           ^^
    ^^                  _l_ widen           ^^
    ^^                  _s_ swap            ^^
    ^^                  ^^                  ^^
    "
    ("q" nil)
    ("b" balance-windows)
    ("i" enlarge-window)
    ("j" shrink-window-horizontally)
    ("k" shrink-window)
    ("l" enlarge-window-horizontally)
    ("s" switch-window-then-swap-buffer :color blue)
    ("-" text-scale-decrease)
    ("+" text-scale-increase)
    ("=" (text-scale-increase 0)))
#+END_SRC

** Ivy

I used =helm= before, but I find =ivy= faster and lighter.

#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.

[[https://github.com/abo-abo/ivy][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package counsel
    :after ivy
    :delight
    :bind (
	       ("C-x C-d" . counsel-dired-jump)
           ("C-x C-h" . counsel-minibuffer-history)
           ("C-x C-l" . counsel-find-library)
           ("C-x C-r" . counsel-recentf)
           ("C-x C-u" . counsel-unicode-char)
           ("C-x C-v" . counsel-set-variable)
           ("C-c n" . counsel-imenu)
		   ("M-x" . counsel-M-x)
		   )
    :config (counsel-mode)
    :custom (counsel-rg-base-command "rg -S -M 150 --no-heading --line-number --color never %s"))

  (use-package ivy
    :delight
    :defer 0.1
    :bind (("C-x b" . ivy-switch-buffer)
           ("C-x B" . ivy-switch-buffer-other-window)
           ("M-H"   . ivy-resume)
           :map ivy-minibuffer-map
           ("<tab>" . ivy-alt-done)
           ("C-i" . ivy-partial-or-done)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-switch-buffer-kill))
    :custom
    (ivy-case-fold-search-default t)
    (ivy-count-format "(%d/%d) ")
    (ivy-re-builders-alist '((t . ivy--regex-plus)))
    (ivy-use-virtual-buffers t)
    :config (ivy-mode))

  (use-package ivy-pass
    :after ivy
    :commands ivy-pass)

  (use-package ivy-rich
    :after ivy
    :custom
    (ivy-virtual-abbreviate 'full
                            ivy-rich-switch-buffer-align-virtual-buffer t
                            ivy-rich-path-style 'abbrev)
    :config (ivy-rich-mode 1))

  (use-package all-the-icons-ivy
    :after (all-the-icons ivy)
    :custom (all-the-icons-ivy-buffer-commands '(ivy-switch-buffer-other-window))
    :config
    (add-to-list 'all-the-icons-ivy-file-commands 'counsel-dired-jump)
    (add-to-list 'all-the-icons-ivy-file-commands 'counsel-find-library)
    (all-the-icons-ivy-setup))

  (use-package swiper
    :after ivy
    :bind (("C-s" . swiper)
           ("C-r" . swiper)
           :map swiper-map
           ("M-%" . swiper-query-replace)))
#+END_SRC
** Parentheses

Managing parentheses can be painful. One of the first things you want to do is
to change the appearance of the highlight of the parentheses pairs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package faces
    :ensure nil
    :custom (show-paren-delay 0)
    :config
    (set-face-background 'show-paren-match "#262b36")
    (set-face-bold 'show-paren-match t)
    (set-face-foreground 'show-paren-match "#ffffff"))
#+END_SRC

*** =rainbow-delimiters=

#+BEGIN_QUOTE
rainbow-delimiters is a "rainbow parentheses"-like mode which highlights
delimiters such as parentheses, brackets or braces according to their
depth. Each successive level is highlighted in a different color. This makes it
easy to spot matching delimiters, orient yourself in the code, and tell which
statements are at a given depth.

[[https://github.com/Fanael/rainbow-delimiters][Fanael Linithien]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** =smartparens=

In my opinion, it is the most powerful package to deal with the
parenthesis. Anyway, if you don't like it, you can try taking a look at
=paredit= or =autopair=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smartparens
    :defer 1
    :delight
    :custom (sp-escape-quotes-after-insert nil)
    :config (smartparens-global-mode 1))
#+END_SRC

** Projectile

#+BEGIN_QUOTE
Projectile is a project interaction library for Emacs. Its goal is to provide a
nice set of features operating on a project level without introducing external
dependencies (when feasible). For instance - finding project files has a
portable implementation written in pure Emacs Lisp without the use of GNU find
(but for performance sake an indexing mechanism backed by external commands
exists as well).

[[https://github.com/bbatsov/projectile][Bozhidar Batsov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    ;;:defer 1
    :custom
    (projectile-cache-file (expand-file-name (format "~/.emacs.d/cache/projectile.cache")))
    (projectile-globally-ignored-file-suffixes '(".o" ".a"))
    (projectile-completion-system 'ivy)
    (projectile-enable-caching t)
    (projectile-keymap-prefix (kbd "C-c p"))
    (projectile-require-project nil)
    (projectile-known-projects-file (expand-file-name (format "~/.emacs.d/cache/projectile-bookmarks.eld")))
    (projectile-mode-line '(:eval (projectile-project-name)))
    :config
	(add-to-list 'projectile-globally-ignored-directories ".ccls-cache")
	(projectile-global-mode)
	)

  (use-package counsel-projectile
    :after (counsel projectile)
    :config (counsel-projectile-mode 1))
#+END_SRC

** Recent Files

Provides fast access to the recent files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package recentf
    :bind ("C-c r" . recentf-open-files)
    :init (recentf-mode)
    :custom
    (recentf-exclude (list "COMMIT_EDITMSG"
                           "~$"
                           "/scp:"
                           "/ssh:"
                           "/sudo:"
                           "/tmp/"))
    (recentf-max-menu-items 15)
    (recentf-max-saved-items 200)
    (recentf-save-file (expand-file-name (format "~/.emacs.d/cache/recentf")))
    :config (run-at-time nil (* 5 60) 'recentf-save-list))
#+END_SRC

** Version Control

It is quite common to work on Git repositories, so it is important to have a
configuration that we like.

#+BEGIN_QUOTE
[[https://github.com/magit/magit][Magit]] is an interface to the version control system Git, implemented as an Emacs
package. Magit aspires to be a complete Git porcelain. While we cannot (yet)
claim that Magit wraps and improves upon each and every Git command, it is
complete enough to allow even experienced Git users to perform almost all of
their daily version control tasks directly from within Emacs. While many fine
Git clients exist, only Magit and Git itself deserve to be called porcelains.

[[https://github.com/tarsius][Jonas Bernoulli]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-commit
    :after magit
    :hook (git-commit-mode . my/git-commit-auto-fill-everywhere)
    :custom (git-commit-summary-max-length 50)
    :preface
    (defun my/git-commit-auto-fill-everywhere ()
      "Ensures that the commit body does not exceed 72 characters."
      (setq fill-column 72)
      (setq-local comment-auto-fill-only-comments nil)))

  (use-package magit :defer 0.3)

   (use-package hl-todo
     :init
	 (add-hook 'after-init-hook 'global-hl-todo-mode)
   )

   (use-package magit-todos
   )

#+END_SRC

In addition to that, I like to see the lines that are being modified in the file
while it is being edited.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-gutter
    :defer 0.3
    :delight
    :init (global-git-gutter-mode +1))
#+END_SRC

Finally, one last package that I like to use with Git to easily see the changes
made by previous commits.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-timemachine
    :defer 1
    :delight)
#+END_SRC

** Whitespaces

It is often annoying to see unnecessary blank spaces at the end of a line or
file. Let's get ride of them:

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package simple
    :ensure nil
    :hook (before-save . delete-trailing-whitespace))
#+END_SRC
** Word Wrap

I like to have lines of the same length.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package simple
    :ensure nil
    :delight (auto-fill-function)
    :bind ("C-x p" . pop-to-mark-command)
    :hook ((prog-mode . turn-on-auto-fill)
           (text-mode . turn-on-auto-fill))
    :custom (set-mark-command-repeat-pop t))
#+END_SRC

** YASnippet

#+BEGIN_QUOTE
YASnippet is a template system for Emacs. It allows you to type an abbreviation
and automatically expand it into function templates.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yasnippet-snippets
    :after yasnippet
    :config (yasnippet-snippets-initialize))

  (use-package yasnippet
    :defer t
	:init
	  (add-hook 'prog-mode-hook 'yas-minor-mode))

  (use-package ivy-yasnippet :after yasnippet)
  (use-package auto-yasnippet :after yasnippet)
  (use-package react-snippets :after yasnippet)
#+END_SRC
** Number Window
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package window-numbering			;
	:init
	(window-numbering-mode 1)
	:config
	(setq window-numbering-assign-func
		(lambda () (when (equal (buffer-name) "*Calculator*") 9)))
  )
#+END_SRC
** Whole line or region
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package whole-line-or-region
     :init
	 (add-hook 'after-init-hook 'whole-line-or-region-mode)
   )
   #+END_SRC

** Symbol overlay
   hight light symbol in different color
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package symbol-overlay
     :bind (("M-i" . symbol-overlay-put)
	        ("M-n" . symbol-overlay-jump-next)
			("M-p" . symbol-overlay-jump-prev)
	       )
   )
   #+END_SRC
** Smex
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package smex
    :init
	(smex-initialize)
;;    :bind (("M-x" . smex)
;;	       ("M-X" . smex-major-mode-commands)
;;		   ("C-c C-c M-x" . execute-extended-command)
;;	      )
  )

  (use-package helm-smex
    :bind (("M-x" . helm-smex)
	       ("M-X" . helm-smex-major-mode-commands)
	      )
  )
#+END_SRC
** Add mutil iedit
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package iedit						;
  )

#+END_SRC
* Org-mode
