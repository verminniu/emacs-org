#+TITLE:  Vermin's Emacs Configuration

* Emacs Initialization

** Packages Sources

In order to install packages, it is useful to configure the package sources.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq package-archives '(("gnu" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
                           ("melpa" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/")
                           ("org" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/org/")))
#+END_SRC

** use-package

To be able to manage its configuration with =use-package= it is necessary to
first install it, if you don't already.

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (use-package delight :ensure t)
  (use-package use-package-ensure-system-package :ensure t)
#+END_SRC

* Start Up
** Better defaults

For a better user experience of GNU Emacs, here are the default values I use.

#+BEGIN_SRC emacs-lisp :tangle yes
	(setq-default
	 ad-redefinition-action 'accept                   ; Silence warnings for redefinition
	 cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
	 display-time-default-load-average nil            ; Don't display load average
	 fill-column 80                                   ; Set width for automatic line breaks
	 mode-require-final-newline t                     ; add a newline to end of file
	 help-window-select t                             ; Focus new help windows when opened
	 inhibit-startup-screen t                         ; Disable start-up screen
	 initial-scratch-message ""                       ; Empty the initial *scratch* buffer
	 kill-ring-max 128                                ; Maximum length of kill ring
	 load-prefer-newer t                              ; Prefers the newest version of a file
	 mark-ring-max 128                                ; Maximum length of mark ring
	 scroll-conservatively most-positive-fixnum       ; Always scroll by one line
	 select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
	 tab-width 4                                      ; Set width for tabs
	 use-package-always-ensure t                      ; Avoid the :ensure keyword for each package
	 user-full-name "Vermin"                          ; Set the full name of the current user
	 user-mail-address "cattlenzq@163.com"            ; Set the email address of the current user
	 vc-follow-symlinks t                             ; Always follow the symlinks
	 view-read-only t)                                ; Always open read-only buffers in view-mode
  ;  (cd "~/")                                         ; Move to the user directory
	(column-number-mode 1)                            ; Show the column number
	(display-time-mode 1)                             ; Enable time in the mode-line
	(fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
	(global-hl-line-mode)                             ; Hightlight current line
	(set-default-coding-systems 'utf-8)               ; Default to utf-8 encoding
	;;(set-default-coding-systems 'gb2312)               ; Default to gb2312 encoding
	;;(set-terminal-coding-system 'gb2312)
	;;(set-keyboard-coding-system 'gb2312)
	;;(set-language-environment "Chinese-GB")
	(prefer-coding-system 'gb2312)		;
	(show-paren-mode 1)                               ; Show the parent
	(add-to-list 'auto-mode-alist '("\\.inl\\'" . c++-mode))
	(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+END_SRC

** Customization

To avoid overloading the GNU Emacs custormization =init.el= file made by the
user with the UI, I add the generated code in a separate file.

I also made sure to follow the XDG base directory specification for the
=auto-save-file= folder, in order to keep my =~/.emacs.d= folder clean.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default
   auto-save-list-file-name (expand-file-name (format "~/.emacs.d/data/auto-save-list"))
   custom-file (expand-file-name (format "~/.emacs.d/data/custom.el")))
  (when (file-exists-p custom-file)
    (load custom-file t))
#+END_SRC

** Theme

I'm a big fan of [[https://github.com/arcticicestudio/nord-emacs][nord-theme]] and combined with [[https://github.com/seagle0128/doom-modeline][doom-modeline]], it's just
happiness.

*NOTE:* to be able to see icons in the =doom-modeline=, you will need to install
[[#Icons][all-the-icons]].

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package nord-theme
    :config
    (add-to-list 'custom-theme-load-path (expand-file-name "~/.emacs.d/themes/"))
    (load-theme 'nord t))

  (use-package doom-modeline
    :defer 0.1
    :config (doom-modeline-mode))
#+END_SRC

** Turn off mouse interface

Since I never use the mouse with GNU Emacs, I prefer not to use certain
graphical elements as seen as the menu bar, toolbar, scrollbar and tooltip that
I find invasive.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when window-system
    (menu-bar-mode -1)              ; Disable the menu bar
    (scroll-bar-mode -1)            ; Disable the scroll bar
    (tool-bar-mode -1)              ; Disable the tool bar
    (tooltip-mode -1))              ; Disable the tooltips
#+END_SRC

* Languages

* Advanced Configuration
** Company
=company= provides auto-completion at point and to Displays a small pop-in
containing the candidates.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :defer 0.5
    :delight
	:init
	(add-hook 'after-init-hook 'global-company-mode)
    :custom
    (company-begin-commands '(self-insert-command))
    (company-idle-delay .1)
    (company-minimum-prefix-length 2)
    (company-show-numbers t)
    (company-tooltip-align-annotations 't)
    (global-company-mode t)
    :config
    (define-key company-active-map (kbd "C-n") 'company-select-next)
    (define-key company-active-map (kbd "C-p") 'company-select-previous)
  )
#+END_SRC

I use =company= with =company-box= that allows a company front-end with icons.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-box
    :after company
    :delight
    :hook (company-mode . company-box-mode))
#+END_SRC

** Buffers

Buffers can quickly become a mess. For some people, it's not a problem, but I
like being able to find my way easily.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer))

  (use-package ibuffer-projectile
    :after ibuffer
    :preface
    (defun my/ibuffer-projectile ()
      (ibuffer-projectile-set-filter-groups)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))
    :hook (ibuffer . my/ibuffer-projectile))
#+END_SRC

** Ivy

I used =helm= before, but I find =ivy= faster and lighter.

#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.

[[https://github.com/abo-abo/ivy][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package counsel
    :after ivy
    :delight
    :bind (("C-x C-d" . counsel-dired-jump)
           ("C-x C-h" . counsel-minibuffer-history)
           ("C-x C-l" . counsel-find-library)
           ("C-x C-r" . counsel-recentf)
           ("C-x C-u" . counsel-unicode-char)
           ("C-x C-v" . counsel-set-variable))
    :config (counsel-mode)
    :custom (counsel-rg-base-command "rg -S -M 150 --no-heading --line-number --color never %s"))

  (use-package ivy
    :delight
    :defer 0.1
    :bind (("C-x b" . ivy-switch-buffer)
           ("C-x B" . ivy-switch-buffer-other-window)
           ("M-H"   . ivy-resume)
           :map ivy-minibuffer-map
           ("<tab>" . ivy-alt-done)
           ("C-i" . ivy-partial-or-done)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-switch-buffer-kill))
    :custom
    (ivy-case-fold-search-default t)
    (ivy-count-format "(%d/%d) ")
    (ivy-re-builders-alist '((t . ivy--regex-plus)))
    (ivy-use-virtual-buffers t)
    :config (ivy-mode))

  (use-package ivy-pass
    :after ivy
    :commands ivy-pass)

  (use-package ivy-rich
    :after ivy
    :custom
    (ivy-virtual-abbreviate 'full
                            ivy-rich-switch-buffer-align-virtual-buffer t
                            ivy-rich-path-style 'abbrev)
    :config (ivy-rich-mode 1))

  (use-package all-the-icons-ivy
    :after (all-the-icons ivy)
    :custom (all-the-icons-ivy-buffer-commands '(ivy-switch-buffer-other-window))
    :config
    (add-to-list 'all-the-icons-ivy-file-commands 'counsel-dired-jump)
    (add-to-list 'all-the-icons-ivy-file-commands 'counsel-find-library)
    (all-the-icons-ivy-setup))

  (use-package swiper
    :after ivy
    :bind (("C-s" . swiper)
           ("C-r" . swiper)
           :map swiper-map
           ("M-%" . swiper-query-replace)))
#+END_SRC
** Parentheses

Managing parentheses can be painful. One of the first things you want to do is
to change the appearance of the highlight of the parentheses pairs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package faces
    :ensure nil
    :custom (show-paren-delay 0)
    :config
    (set-face-background 'show-paren-match "#262b36")
    (set-face-bold 'show-paren-match t)
    (set-face-foreground 'show-paren-match "#ffffff"))
#+END_SRC

*** =rainbow-delimiters=

#+BEGIN_QUOTE
rainbow-delimiters is a "rainbow parentheses"-like mode which highlights
delimiters such as parentheses, brackets or braces according to their
depth. Each successive level is highlighted in a different color. This makes it
easy to spot matching delimiters, orient yourself in the code, and tell which
statements are at a given depth.

[[https://github.com/Fanael/rainbow-delimiters][Fanael Linithien]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** =smartparens=

In my opinion, it is the most powerful package to deal with the
parenthesis. Anyway, if you don't like it, you can try taking a look at
=paredit= or =autopair=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smartparens
    :defer 1
    :delight
    :custom (sp-escape-quotes-after-insert nil)
    :config (smartparens-global-mode 1))
#+END_SRC

** Projectile

#+BEGIN_QUOTE
Projectile is a project interaction library for Emacs. Its goal is to provide a
nice set of features operating on a project level without introducing external
dependencies (when feasible). For instance - finding project files has a
portable implementation written in pure Emacs Lisp without the use of GNU find
(but for performance sake an indexing mechanism backed by external commands
exists as well).

[[https://github.com/bbatsov/projectile][Bozhidar Batsov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    ;;:defer 1
    :custom
    (projectile-cache-file (expand-file-name (format "~/.emacs.d/cache/projectile.cache")))
    (projectile-globally-ignored-file-suffixes '(".o" ".a"))
    (projectile-completion-system 'ivy)
    (projectile-enable-caching t)
    (projectile-keymap-prefix (kbd "C-c p"))
    (projectile-require-project nil)
    (projectile-known-projects-file (expand-file-name (format "~/.emacs.d/cache/projectile-bookmarks.eld")))
    (projectile-mode-line '(:eval (projectile-project-name)))
    :config
	(setq projectile-globally-ignored-file-suffixes '(".o" ".a"))
	(setq projectile-enable-caching t)
	(projectile-global-mode)
	)

  (use-package counsel-projectile
    :after (counsel projectile)
    :config (counsel-projectile-mode 1))
#+END_SRC

** Version Control

It is quite common to work on Git repositories, so it is important to have a
configuration that we like.

#+BEGIN_QUOTE
[[https://github.com/magit/magit][Magit]] is an interface to the version control system Git, implemented as an Emacs
package. Magit aspires to be a complete Git porcelain. While we cannot (yet)
claim that Magit wraps and improves upon each and every Git command, it is
complete enough to allow even experienced Git users to perform almost all of
their daily version control tasks directly from within Emacs. While many fine
Git clients exist, only Magit and Git itself deserve to be called porcelains.

[[https://github.com/tarsius][Jonas Bernoulli]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-commit
    :after magit
    :hook (git-commit-mode . my/git-commit-auto-fill-everywhere)
    :custom (git-commit-summary-max-length 50)
    :preface
    (defun my/git-commit-auto-fill-everywhere ()
      "Ensures that the commit body does not exceed 72 characters."
      (setq fill-column 72)
      (setq-local comment-auto-fill-only-comments nil)))

  (use-package magit :defer 0.3)
#+END_SRC

In addition to that, I like to see the lines that are being modified in the file
while it is being edited.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-gutter
    :defer 0.3
    :delight
    :init (global-git-gutter-mode +1))
#+END_SRC

Finally, one last package that I like to use with Git to easily see the changes
made by previous commits.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-timemachine
    :defer 1
    :delight)
#+END_SRC

** Whitespaces

It is often annoying to see unnecessary blank spaces at the end of a line or
file. Let's get ride of them:

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package simple
    :ensure nil
    :hook (before-save . delete-trailing-whitespace))
#+END_SRC

*** =hungry-delete=

#+BEGIN_QUOTE
Deleting a whitespace character will delete all whitespace until the next
non-whitespace character.

[[https://github.com/nflath/hungry-delete][Nathaniel Flath]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hungry-delete
    :defer 0.7
    :delight
    :config (global-hungry-delete-mode))
#+END_SRC
** Word Wrap

I like to have lines of the same length.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package simple
    :ensure nil
    :delight (auto-fill-function)
    :bind ("C-x p" . pop-to-mark-command)
    :hook ((prog-mode . turn-on-auto-fill)
           (text-mode . turn-on-auto-fill))
    :custom (set-mark-command-repeat-pop t))
#+END_SRC

** YASnippet

#+BEGIN_QUOTE
YASnippet is a template system for Emacs. It allows you to type an abbreviation
and automatically expand it into function templates.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yasnippet-snippets
    :after yasnippet
    :config (yasnippet-snippets-initialize))

  (use-package yasnippet
    :delight yas-minor-mode " Ï…"
    :hook (yas-minor-mode . my/disable-yas-if-no-snippets)
    :config (yas-global-mode)
    :preface
    (defun my/disable-yas-if-no-snippets ()
      (when (and yas-minor-mode (null (yas--get-snippet-tables)))
        (yas-minor-mode -1))))

  (use-package ivy-yasnippet :after yasnippet)
  (use-package react-snippets :after yasnippet)
#+END_SRC
** Number Window
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package window-numbering			;
	:init
	(window-numbering-mode 1)
	:config
	(setq window-numbering-assign-func
		(lambda () (when (equal (buffer-name) "*Calculator*") 9)))
  )
#+END_SRC
** Add mutil iedit
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package iedit						;
  )

#+END_SRC
